// +build go1.12
// +build !go1.15

package goloader

import (
	"encoding/binary"
	"fmt"
	"unsafe"
)

const stackObjectRecordSize = unsafe.Sizeof(stackObjectRecord{})

// A stackObjectRecord is generated by the compiler for each stack object in a stack frame.
// This record must match the generator code in cmd/compile/internal/gc/ssa.go:emitStackObjects.
type stackObjectRecord struct {
	// offset in frame
	// if negative, offset from varp
	// if non-negative, offset from argp
	off int
	typ *_type
}

func _addStackObject(codereloc *CodeReloc, funcdata *funcData, seg *segment) {
	if len(funcdata.Func.FuncData) > _FUNCDATA_StackObjects &&
		codereloc.stkmaps[funcdata.Func.FuncData[_FUNCDATA_StackObjects].Sym.Name] != nil {
		b := codereloc.stkmaps[funcdata.Func.FuncData[_FUNCDATA_StackObjects].Sym.Name]
		n := *(*int)(unsafe.Pointer(&b[0]))
		p := unsafe.Pointer(&b[PtrSize])
		for i := 0; i < n; i++ {
			obj := *(*stackObjectRecord)(p)
			name := EMPTY_STRING
			for _, v := range funcdata.Func.Var {
				if v.Offset == (int64)(obj.off) {
					name = v.Type.Name
					break
				}
			}
			if len(name) == 0 {
				name = funcdata.stkobjReloc[i].Sym.Name
			}
			if ptr, ok := seg.symbolMap[name]; !ok {
				seg.errors += fmt.Sprintf("unresolve external Var! Function name:%s index:%d, name:%s\n", funcdata.Name, i, name)
			} else {
				off := PtrSize + i*(int)(stackObjectRecordSize) + PtrSize
				if PtrSize == 4 {
					binary.LittleEndian.PutUint32(b[off:], *(*uint32)(unsafe.Pointer(&ptr)))
				} else {
					binary.LittleEndian.PutUint64(b[off:], *(*uint64)(unsafe.Pointer(&ptr)))
				}
			}
			p = add(p, stackObjectRecordSize)
		}
	}
}
